/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import moment from 'moment';

export interface IBoardsClient {
    get(shortUrl: string | null): Promise<BoardDto>;
}

export class BoardsClient implements IBoardsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(shortUrl: string | null): Promise<BoardDto> {
        let url_ = this.baseUrl + "/api/Boards/{shortUrl}";
        if (shortUrl === undefined || shortUrl === null)
            throw new Error("The parameter 'shortUrl' must be defined.");
        url_ = url_.replace("{shortUrl}", encodeURIComponent("" + shortUrl));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<BoardDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoardDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoardDto>(<any>null);
    }
}

export interface IGroupsClient {
    get(): Promise<GroupDto[]>;
}

export class GroupsClient implements IGroupsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<GroupDto[]> {
        let url_ = this.baseUrl + "/api/Groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<GroupDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupDto[]>(<any>null);
    }
}

export interface IPostsClient {
    get(id: number): Promise<PostDto>;
    create(topicId: number | undefined, parentPostId: number | null | undefined, text: string | null | undefined, isOp: boolean | undefined, signature: string | null | undefined, attachments: FileParameter[] | null | undefined): Promise<number>;
}

export class PostsClient implements IPostsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(id: number): Promise<PostDto> {
        let url_ = this.baseUrl + "/api/Posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<PostDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PostDto>(<any>null);
    }

    create(topicId: number | undefined, parentPostId: number | null | undefined, text: string | null | undefined, isOp: boolean | undefined, signature: string | null | undefined, attachments: FileParameter[] | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Posts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (topicId === null || topicId === undefined)
            throw new Error("The parameter 'topicId' cannot be null.");
        else
            content_.append("TopicId", topicId.toString());
        if (parentPostId !== null && parentPostId !== undefined)
            content_.append("ParentPostId", parentPostId.toString());
        if (text !== null && text !== undefined)
            content_.append("Text", text.toString());
        if (isOp === null || isOp === undefined)
            throw new Error("The parameter 'isOp' cannot be null.");
        else
            content_.append("IsOp", isOp.toString());
        if (signature !== null && signature !== undefined)
            content_.append("Signature", signature.toString());
        if (attachments !== null && attachments !== undefined)
            attachments.forEach(item_ => content_.append("Attachments", item_.data, item_.fileName ? item_.fileName : "Attachments") );

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }
}

export interface ITopicsClient {
    get(id: number): Promise<TopicDto>;
    create(boardId: number | undefined, title: string | null | undefined, text: string | null | undefined, signature: string | null | undefined, attachments: FileParameter[] | null | undefined): Promise<number>;
}

export class TopicsClient implements ITopicsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(id: number): Promise<TopicDto> {
        let url_ = this.baseUrl + "/api/Topics/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TopicDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TopicDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TopicDto>(<any>null);
    }

    create(boardId: number | undefined, title: string | null | undefined, text: string | null | undefined, signature: string | null | undefined, attachments: FileParameter[] | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Topics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (boardId === null || boardId === undefined)
            throw new Error("The parameter 'boardId' cannot be null.");
        else
            content_.append("BoardId", boardId.toString());
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (text !== null && text !== undefined)
            content_.append("Text", text.toString());
        if (signature !== null && signature !== undefined)
            content_.append("Signature", signature.toString());
        if (attachments !== null && attachments !== undefined)
            attachments.forEach(item_ => content_.append("Attachments", item_.data, item_.fileName ? item_.fileName : "Attachments") );

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class BoardDto implements IBoardDto {
    id!: number;
    shortUrl?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    sortOrder!: number;
    topics?: TopicShortDto[] | undefined;
    groupId!: number;

    constructor(data?: IBoardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shortUrl = _data["shortUrl"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            if (Array.isArray(_data["topics"])) {
                this.topics = [] as any;
                for (let item of _data["topics"])
                    this.topics!.push(TopicShortDto.fromJS(item));
            }
            this.groupId = _data["groupId"];
        }
    }

    static fromJS(data: any): BoardDto {
        data = typeof data === 'object' ? data : {};
        let result = new BoardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shortUrl"] = this.shortUrl;
        data["title"] = this.title;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        if (Array.isArray(this.topics)) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item.toJSON());
        }
        data["groupId"] = this.groupId;
        return data; 
    }
}

export interface IBoardDto {
    id: number;
    shortUrl?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    sortOrder: number;
    topics?: TopicShortDto[] | undefined;
    groupId: number;
}

export class TopicShortDto implements ITopicShortDto {
    id!: number;
    title?: string | undefined;
    signature?: string | undefined;
    text?: string | undefined;
    created!: moment.Moment;
    lastUpdated!: moment.Moment;
    postCount!: number;
    board?: BoardShortDto | undefined;

    constructor(data?: ITopicShortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.signature = _data["signature"];
            this.text = _data["text"];
            this.created = _data["created"] ? moment.parseZone(_data["created"].toString()) : <any>undefined;
            this.lastUpdated = _data["lastUpdated"] ? moment.parseZone(_data["lastUpdated"].toString()) : <any>undefined;
            this.postCount = _data["postCount"];
            this.board = _data["board"] ? BoardShortDto.fromJS(_data["board"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TopicShortDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopicShortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["signature"] = this.signature;
        data["text"] = this.text;
        data["created"] = this.created ? this.created.toISOString(true) : <any>undefined;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString(true) : <any>undefined;
        data["postCount"] = this.postCount;
        data["board"] = this.board ? this.board.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITopicShortDto {
    id: number;
    title?: string | undefined;
    signature?: string | undefined;
    text?: string | undefined;
    created: moment.Moment;
    lastUpdated: moment.Moment;
    postCount: number;
    board?: BoardShortDto | undefined;
}

export class BoardShortDto implements IBoardShortDto {
    id!: number;
    shortUrl?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    sortOrder!: number;

    constructor(data?: IBoardShortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shortUrl = _data["shortUrl"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): BoardShortDto {
        data = typeof data === 'object' ? data : {};
        let result = new BoardShortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shortUrl"] = this.shortUrl;
        data["title"] = this.title;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IBoardShortDto {
    id: number;
    shortUrl?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    sortOrder: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        this.extensions![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    data["extensions"][key] = this.extensions[key];
            }
        }
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export class ValidationProblemDetails extends ProblemDetails implements IValidationProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;

    constructor(data?: IValidationProblemDetails) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        this.errors![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    data["errors"][key] = this.errors[key];
            }
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;
}

export class GroupDto implements IGroupDto {
    id!: number;
    sortOrder!: number;
    title?: string | undefined;
    description?: string | undefined;
    boards?: BoardShortDto[] | undefined;

    constructor(data?: IGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sortOrder = _data["sortOrder"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["boards"])) {
                this.boards = [] as any;
                for (let item of _data["boards"])
                    this.boards!.push(BoardShortDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.boards)) {
            data["boards"] = [];
            for (let item of this.boards)
                data["boards"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGroupDto {
    id: number;
    sortOrder: number;
    title?: string | undefined;
    description?: string | undefined;
    boards?: BoardShortDto[] | undefined;
}

export class PostDto implements IPostDto {
    id!: number;
    signature?: string | undefined;
    isOp!: boolean;
    text?: string | undefined;
    created!: moment.Moment;
    topicId!: number;
    parentId?: number | undefined;
    children?: PostDto[] | undefined;
    attachments?: AttachmentDto[] | undefined;

    constructor(data?: IPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.signature = _data["signature"];
            this.isOp = _data["isOp"];
            this.text = _data["text"];
            this.created = _data["created"] ? moment.parseZone(_data["created"].toString()) : <any>undefined;
            this.topicId = _data["topicId"];
            this.parentId = _data["parentId"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(PostDto.fromJS(item));
            }
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PostDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["signature"] = this.signature;
        data["isOp"] = this.isOp;
        data["text"] = this.text;
        data["created"] = this.created ? this.created.toISOString(true) : <any>undefined;
        data["topicId"] = this.topicId;
        data["parentId"] = this.parentId;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPostDto {
    id: number;
    signature?: string | undefined;
    isOp: boolean;
    text?: string | undefined;
    created: moment.Moment;
    topicId: number;
    parentId?: number | undefined;
    children?: PostDto[] | undefined;
    attachments?: AttachmentDto[] | undefined;
}

export class AttachmentDto implements IAttachmentDto {
    id!: number;
    originalFilename?: string | undefined;
    filename?: string | undefined;
    contentType?: string | undefined;
    size!: number;
    created!: moment.Moment;
    postId!: number;

    constructor(data?: IAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.originalFilename = _data["originalFilename"];
            this.filename = _data["filename"];
            this.contentType = _data["contentType"];
            this.size = _data["size"];
            this.created = _data["created"] ? moment.parseZone(_data["created"].toString()) : <any>undefined;
            this.postId = _data["postId"];
        }
    }

    static fromJS(data: any): AttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["originalFilename"] = this.originalFilename;
        data["filename"] = this.filename;
        data["contentType"] = this.contentType;
        data["size"] = this.size;
        data["created"] = this.created ? this.created.toISOString(true) : <any>undefined;
        data["postId"] = this.postId;
        return data; 
    }
}

export interface IAttachmentDto {
    id: number;
    originalFilename?: string | undefined;
    filename?: string | undefined;
    contentType?: string | undefined;
    size: number;
    created: moment.Moment;
    postId: number;
}

export class TopicDto implements ITopicDto {
    id!: number;
    title?: string | undefined;
    signature?: string | undefined;
    created!: moment.Moment;
    lastUpdated!: moment.Moment;
    boardId!: number;
    posts?: PostDto[] | undefined;
    board?: BoardShortDto | undefined;

    constructor(data?: ITopicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.signature = _data["signature"];
            this.created = _data["created"] ? moment.parseZone(_data["created"].toString()) : <any>undefined;
            this.lastUpdated = _data["lastUpdated"] ? moment.parseZone(_data["lastUpdated"].toString()) : <any>undefined;
            this.boardId = _data["boardId"];
            if (Array.isArray(_data["posts"])) {
                this.posts = [] as any;
                for (let item of _data["posts"])
                    this.posts!.push(PostDto.fromJS(item));
            }
            this.board = _data["board"] ? BoardShortDto.fromJS(_data["board"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TopicDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["signature"] = this.signature;
        data["created"] = this.created ? this.created.toISOString(true) : <any>undefined;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString(true) : <any>undefined;
        data["boardId"] = this.boardId;
        if (Array.isArray(this.posts)) {
            data["posts"] = [];
            for (let item of this.posts)
                data["posts"].push(item.toJSON());
        }
        data["board"] = this.board ? this.board.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITopicDto {
    id: number;
    title?: string | undefined;
    signature?: string | undefined;
    created: moment.Moment;
    lastUpdated: moment.Moment;
    boardId: number;
    posts?: PostDto[] | undefined;
    board?: BoardShortDto | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

/* tslint:disable */
/* eslint-disable */

// Custom imports for API client